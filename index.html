<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåå VR Anime Universe</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }
        
        body {
            background: linear-gradient(45deg, #1a1a2e, #16213e, #0f3460);
            color: white;
        }
        
        #vr-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }
        
        .vr-hud {
            position: absolute;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid cyan;
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(10px);
            pointer-events: auto;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 255, 0.3); }
            50% { box-shadow: 0 0 30px rgba(0, 255, 255, 0.6); }
        }
        
        .top-left {
            top: 20px;
            left: 20px;
        }
        
        .top-right {
            top: 20px;
            right: 20px;
        }
        
        .bottom-center {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .control-button {
            background: linear-gradient(45deg, #ff00ff, #00ffff);
            border: none;
            padding: 12px 24px;
            margin: 5px;
            border-radius: 25px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.4);
        }
        
        .control-button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 25px rgba(255, 0, 255, 0.8);
        }
        
        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #000000, #1a1a2e, #16213e);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            transition: opacity 1s;
        }
        
        .loading-text {
            font-size: 2em;
            margin: 20px;
            animation: glow 2s infinite alternate;
        }
        
        @keyframes glow {
            from { text-shadow: 0 0 10px #00ffff; }
            to { text-shadow: 0 0 20px #ff00ff, 0 0 30px #00ffff; }
        }
        
        .portal-ring {
            width: 200px;
            height: 200px;
            border: 5px solid transparent;
            border-radius: 50%;
            background: linear-gradient(45deg, #ff00ff, #00ffff, #ffff00);
            animation: rotate 3s linear infinite;
            position: relative;
        }
        
        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .portal-ring::before {
            content: '';
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            bottom: 10px;
            background: #000;
            border-radius: 50%;
        }
        
        #dimension-info {
            font-size: 1.2em;
            text-align: center;
        }
        
        .reality-status {
            color: #00ff00;
            animation: flicker 1s infinite;
        }
        
        @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .vr-ready {
            background: linear-gradient(45deg, #00ff00, #00ffff);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="vr-container">
        <!-- Loading Screen -->
        <div id="loading-screen">
            <div class="portal-ring"></div>
            <div class="loading-text">üåå INITIALIZING VR ANIME UNIVERSE üåå</div>
            <div class="loading-text">Reality Loading... <span id="load-progress">0</span>%</div>
        </div>
        
        <!-- VR UI Overlay -->
        <div id="ui-overlay">
            <!-- Top Left HUD -->
            <div class="vr-hud top-left">
                <div class="vr-ready">ü•Ω VR READY</div>
                <div>Dimension: <span id="current-dimension">Cyber Forest</span></div>
                <div>Reality Level: <span class="reality-status" id="reality-level">STABLE</span></div>
                <div>Entities: <span id="entity-count">7</span></div>
            </div>
            
            <!-- Top Right HUD -->
            <div class="vr-hud top-right">
                <div id="dimension-info">
                    <div>üéå Current World</div>
                    <div><strong>Neo-Tokyo Skylands</strong></div>
                    <div>Population: 847 AI Beings</div>
                    <div>Weather: Neon Rain ‚ö°</div>
                </div>
            </div>
            
            <!-- Bottom Controls -->
            <div class="vr-hud bottom-center">
                <button class="control-button" onclick="changeReality()">üåÄ SHIFT REALITY</button>
                <button class="control-button" onclick="toggleVRMode()">ü•Ω VR MODE</button>
                <button class="control-button" onclick="spawnEntity()">üëæ SPAWN BEING</button>
                <button class="control-button" onclick="alterTime()">‚è∞ TIME WARP</button>
                <button class="control-button" onclick="createPortal()">üåå PORTAL</button>
            </div>
        </div>
    </div>

    <script>
        // VR Universe Variables
        let scene, camera, renderer, world;
        let currentDimension = 0;
        let entities = [];
        let portals = [];
        let timeWarp = 1;
        let realityLevel = 'STABLE';
        
        // Dimension Themes
        const dimensions = [
            { name: 'Cyber Forest', color: 0x00ff88, music: 'mystical', population: 234 },
            { name: 'Neon City', color: 0xff0088, music: 'electronic', population: 847 },
            { name: 'Sky Islands', color: 0x0088ff, music: 'ethereal', population: 156 },
            { name: 'Crystal Caves', color: 0x8800ff, music: 'ambient', population: 623 },
            { name: 'Space Station', color: 0xffff00, music: 'cosmic', population: 392 }
        ];
        
        // Initialize VR Universe
        function initVRUniverse() {
            // Create Three.js scene
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000011, 1);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            document.getElementById('vr-container').appendChild(renderer.domElement);
            
            // Create initial world
            createAnimeWorld();
            
            // Add lights
            addDynamicLighting();
            
            // Position camera
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);
            
            // Start animation loop
            animate();
            
            // Simulate loading
            simulateLoading();
            
            // Add mouse controls
            addMouseControls();
            
            // Add random events
            setInterval(randomWorldEvent, 5000);
        }
        
        function createAnimeWorld() {
            // Clear existing world
            while(scene.children.length > 0) {
                scene.remove(scene.children[0]);
            }
            
            const currentDim = dimensions[currentDimension];
            
            // Create ground
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: currentDim.color,
                transparent: true,
                opacity: 0.7
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Create floating islands
            for(let i = 0; i < 5; i++) {
                createFloatingIsland(
                    Math.random() * 40 - 20,
                    Math.random() * 10 + 5,
                    Math.random() * 40 - 20,
                    currentDim.color
                );
            }
            
            // Create anime-style buildings
            for(let i = 0; i < 8; i++) {
                createAnimeBuilding(
                    Math.random() * 30 - 15,
                    0,
                    Math.random() * 30 - 15,
                    currentDim.color
                );
            }
            
            // Add flying entities
            spawnAnimeEntities();
            
            // Create particle effects
            createParticleSystem(currentDim.color);
            
            // Update UI
            updateDimensionUI();
        }
        
        function createFloatingIsland(x, y, z, color) {
            const islandGeometry = new THREE.SphereGeometry(3, 16, 16);
            const islandMaterial = new THREE.MeshPhongMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.8
            });
            islandMaterial.emissive.setHex(color);
            islandMaterial.emissiveIntensity = 0.2;
            
            const island = new THREE.Mesh(islandGeometry, islandMaterial);
            island.position.set(x, y, z);
            island.castShadow = true;
            
            // Add floating animation
            island.userData = { 
                originalY: y, 
                floatSpeed: Math.random() * 0.02 + 0.01,
                floatRange: Math.random() * 2 + 1
            };
            
            scene.add(island);
            
            // Add glowing orb on top
            const orbGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const orbMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                transparent: true,
                opacity: 0.9
            });
            const orb = new THREE.Mesh(orbGeometry, orbMaterial);
            orb.position.set(x, y + 4, z);
            scene.add(orb);
        }
        
        function createAnimeBuilding(x, y, z, color) {
            const height = Math.random() * 8 + 4;
            const buildingGeometry = new THREE.BoxGeometry(2, height, 2);
            const buildingMaterial = new THREE.MeshPhongMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.6
            });
            
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            building.position.set(x, height/2, z);
            building.castShadow = true;
            scene.add(building);
            
            // Add animated windows
            for(let i = 0; i < 3; i++) {
                const windowGeometry = new THREE.PlaneGeometry(0.3, 0.3);
                const windowMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00,
                    transparent: true,
                    opacity: Math.random() * 0.8 + 0.2
                });
                const window = new THREE.Mesh(windowGeometry, windowMaterial);
                window.position.set(x + 1.1, height/2 + i * 1.5, z);
                scene.add(window);
                
                // Animate window lights
                window.userData = { flickerSpeed: Math.random() * 0.1 + 0.05 };
            }
        }
        
        function spawnAnimeEntities() {
            entities = [];
            for(let i = 0; i < 7; i++) {
                createAnimeEntity();
            }
        }
        
        function createAnimeEntity() {
            const entityGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const entityMaterial = new THREE.MeshPhongMaterial({ 
                color: Math.random() * 0xffffff,
                transparent: true,
                opacity: 0.8
            });
            entityMaterial.emissive.setHex(Math.random() * 0xffffff);
            entityMaterial.emissiveIntensity = 0.3;
            
            const entity = new THREE.Mesh(entityGeometry, entityMaterial);
            entity.position.set(
                Math.random() * 20 - 10,
                Math.random() * 8 + 2,
                Math.random() * 20 - 10
            );
            
            // Add movement behavior
            entity.userData = {
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.05,
                    (Math.random() - 0.5) * 0.1
                ),
                personality: Math.random() > 0.5 ? 'curious' : 'wanderer'
            };
            
            entities.push(entity);
            scene.add(entity);
        }
        
        function createParticleSystem(color) {
            const particleCount = 1000;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            
            for(let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = Math.random() * 100 - 50;
                positions[i + 1] = Math.random() * 50;
                positions[i + 2] = Math.random() * 100 - 50;
            }
            
            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                color: color,
                size: 0.1,
                transparent: true,
                opacity: 0.6
            });
            
            const particleSystem = new THREE.Points(particles, particleMaterial);
            scene.add(particleSystem);
            
            // Animate particles
            particleSystem.userData = { rotationSpeed: 0.001 };
        }
        
        function addDynamicLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            // Main directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Colored accent lights
            const colors = [0xff0088, 0x00ff88, 0x0088ff];
            for(let i = 0; i < 3; i++) {
                const light = new THREE.PointLight(colors[i], 0.5, 30);
                light.position.set(
                    Math.sin(i * 2) * 15,
                    10,
                    Math.cos(i * 2) * 15
                );
                scene.add(light);
            }
        }
        
        function addMouseControls() {
            let mouseX = 0, mouseY = 0;
            
            document.addEventListener('mousemove', (event) => {
                mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
                
                // Move camera based on mouse
                camera.position.x = mouseX * 5;
                camera.position.y = 5 + mouseY * 3;
                camera.lookAt(0, 0, 0);
            });
            
            document.addEventListener('click', (event) => {
                // Create explosion effect at click
                createClickEffect(event.clientX, event.clientY);
            });
        }
        
        function createClickEffect(x, y) {
            // Convert screen coordinates to world coordinates
            const mouse = new THREE.Vector2(
                (x / window.innerWidth) * 2 - 1,
                -(y / window.innerHeight) * 2 + 1
            );
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            // Create explosion effect
            const explosionGeometry = new THREE.SphereGeometry(1, 16, 16);
            const explosionMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8
            });
            
            const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
            explosion.position.copy(raycaster.ray.origin);
            explosion.position.add(raycaster.ray.direction.multiplyScalar(10));
            scene.add(explosion);
            
            // Animate explosion
            let scale = 0;
            const animateExplosion = () => {
                scale += 0.2;
                explosion.scale.setScalar(scale);
                explosion.material.opacity = 1 - (scale / 5);
                
                if(scale < 5) {
                    requestAnimationFrame(animateExplosion);
                } else {
                    scene.remove(explosion);
                }
            };
            animateExplosion();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * 0.001;
            
            // Animate floating islands
            scene.children.forEach(child => {
                if(child.userData && child.userData.floatSpeed) {
                    child.position.y = child.userData.originalY + 
                        Math.sin(time * child.userData.floatSpeed) * child.userData.floatRange;
                }
                
                // Animate window lights
                if(child.userData && child.userData.flickerSpeed) {
                    child.material.opacity = 0.5 + Math.sin(time * child.userData.flickerSpeed * 10) * 0.3;
                }
                
                // Animate particle systems
                if(child.userData && child.userData.rotationSpeed) {
                    child.rotation.y += child.userData.rotationSpeed;
                }
            });
            
            // Animate entities
            entities.forEach(entity => {
                if(entity.userData) {
                    entity.position.add(entity.userData.velocity);
                    
                    // Bounce off boundaries
                    if(Math.abs(entity.position.x) > 15) entity.userData.velocity.x *= -1;
                    if(Math.abs(entity.position.z) > 15) entity.userData.velocity.z *= -1;
                    if(entity.position.y > 15 || entity.position.y < 2) entity.userData.velocity.y *= -1;
                    
                    // Add some randomness
                    if(Math.random() < 0.01) {
                        entity.userData.velocity.add(new THREE.Vector3(
                            (Math.random() - 0.5) * 0.02,
                            (Math.random() - 0.5) * 0.01,
                            (Math.random() - 0.5) * 0.02
                        ));
                    }
                }
            });
            
            renderer.render(scene, camera);
        }
        
        function simulateLoading() {
            let progress = 0;
            const loadingInterval = setInterval(() => {
                progress += Math.random() * 15 + 5;
                document.getElementById('load-progress').textContent = Math.min(progress, 100).toFixed(0);
                
                if(progress >= 100) {
                    clearInterval(loadingInterval);
                    setTimeout(() => {
                        document.getElementById('loading-screen').style.opacity = '0';
                        setTimeout(() => {
                            document.getElementById('loading-screen').style.display = 'none';
                        }, 1000);
                    }, 500);
                }
            }, 200);
        }
        
        function updateDimensionUI() {
            const currentDim = dimensions[currentDimension];
            document.getElementById('current-dimension').textContent = currentDim.name;
            document.getElementById('dimension-info').innerHTML = `
                <div>üéå Current World</div>
                <div><strong>${currentDim.name}</strong></div>
                <div>Population: ${currentDim.population} AI Beings</div>
                <div>Music: ${currentDim.music} üéµ</div>
            `;
        }
        
        function randomWorldEvent() {
            const events = [
                () => { realityLevel = 'FLUCTUATING'; setTimeout(() => realityLevel = 'STABLE', 3000); },
                () => { spawnEntity(); },
                () => { createPortal(); },
                () => { 
                    // Change time of day
                    const colors = [0x000011, 0x001133, 0x112244, 0x223355];
                    renderer.setClearColor(colors[Math.floor(Math.random() * colors.length)]);
                }
            ];
            
            events[Math.floor(Math.random() * events.length)]();
            document.getElementById('reality-level').textContent = realityLevel;
            document.getElementById('entity-count').textContent = entities.length;
        }
        
        // Control Functions
        function changeReality() {
            currentDimension = (currentDimension + 1) % dimensions.length;
            createAnimeWorld();
            realityLevel = 'SHIFTING';
            setTimeout(() => realityLevel = 'STABLE', 2000);
        }
        
        function toggleVRMode() {
            // Toggle fullscreen and pointer lock for VR-like experience
            if(!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
                document.body.requestPointerLock();
            } else {
                document.exitFullscreen();
                document.exitPointerLock();
            }
        }
        
        function spawnEntity() {
            if(entities.length < 20) {
                createAnimeEntity();
            }
        }
        
        function alterTime() {
            timeWarp = timeWarp === 1 ? 3 : 1;
            realityLevel = timeWarp === 3 ? 'TIME DILATED' : 'STABLE';
            document.getElementById('reality-level').textContent = realityLevel;
        }
        
        function createPortal() {
            const portalGeometry = new THREE.RingGeometry(2, 3, 16);
            const portalMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide
            });
            
            const portal = new THREE.Mesh(portalGeometry, portalMaterial);
            portal.position.set(
                Math.random() * 20 - 10,
                5,
                Math.random() * 20 - 10
            );
            portal.userData = { spin: 0.05, life: 200 };
            
            scene.add(portal);
            portals.push(portal);
            
            // Remove portal after some time
            setTimeout(() => {
                scene.remove(portal);
                portals = portals.filter(p => p !== portal);
            }, 10000);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Initialize everything
        initVRUniverse();
    </script>
</body>
</html>